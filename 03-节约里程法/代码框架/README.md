下面是节约里程法的Python实现框架，包含详细的使用指南和示例：


[跳转至框架代码](./frame.py)



### 节约里程法Python实现使用指南


#### 一、代码框架概述
这个实现包含一个核心类`SavingsAlgorithm`，它完成以下功能：
1. **数据初始化**：输入配送中心位置、客户点坐标、客户需求和车辆容量
2. **距离计算**：自动计算所有点对之间的欧几里得距离
3. **节约值计算**：计算每对客户点合并后的里程节约值，并排序
4. **路径规划**：基于节约值贪心合并路径，同时满足容量约束
5. **结果可视化**：提供路径可视化和文本摘要输出

#### 二、使用步骤

1. **导入类**
   ```python
   from savings_algorithm import SavingsAlgorithm
   ```

2. **准备数据**
   - `depot`: 配送中心坐标，元组`(x, y)`
   - `customers`: 客户点字典，格式`{客户ID: (x坐标, y坐标)}`
   - `demands`: 客户需求字典，格式`{客户ID: 需求量}`
   - `vehicle_capacity`: 每辆车的容量限制

3. **创建求解器实例**
   ```python
   solver = SavingsAlgorithm(depot, customers, demands, vehicle_capacity)
   ```

4. **求解路径规划问题**
   ```python
   routes = solver.solve()  # 可添加max_distance参数限制单车最大行驶距离
   ```

5. **查看结果**
   ```python
   solver.print_solution(routes)  # 打印文本结果
   solver.visualize_routes(routes)  # 可视化路径
   ```


#### 三、示例说明

##### 示例1：简单测试案例（代码中已包含）
配送中心位于原点`(0,0)`，有5个客户点，坐标和需求如下：
- 客户1: (1,2), 需求3
- 客户2: (3,4), 需求4
- 客户3: (5,1), 需求2
- 客户4: (6,3), 需求5
- 客户5: (2,5), 需求3
车辆容量为10

运行后会输出：
- 所需车辆数
- 总行驶距离
- 每辆车的具体路径、行驶距离和装载量
- 可视化路径图

##### 示例2：城市外卖配送问题
假设你要为一个小型城市规划外卖配送路线：
```python
# 配送中心（餐厅位置）
depot = (5, 5)

# 10个客户点（坐标随机生成）
customers = {
    1: (2, 3), 2: (7, 1), 3: (4, 6), 4: (9, 4), 5: (1, 8),
    6: (8, 7), 7: (3, 2), 8: (6, 9), 9: (2, 5), 10: (5, 3)
}

# 客户需求（外卖订单数量）
demands = {i: np.random.randint(1, 5) for i in customers}

# 车辆容量（每辆车最多送20单）
vehicle_capacity = 20

# 求解并可视化
solver = SavingsAlgorithm(depot, customers, demands, vehicle_capacity)
routes = solver.solve()
solver.print_solution(routes)
solver.visualize_routes(routes, "城市外卖配送路径规划")
```

##### 示例3：带距离限制的物流配送
在示例2基础上，增加单车最大行驶距离限制（如50公里）：
```python
routes = solver.solve(max_distance=50)  # 添加距离限制
```


#### 四、代码扩展建议

1. **处理时间窗约束**：
   - 在合并路径时，检查客户时间窗是否冲突
   - 可添加`time_windows`参数，格式为`{客户ID: (最早服务时间, 最晚服务时间)}`

2. **支持多配送中心**：
   - 对每个配送中心分别运行算法
   - 或修改算法，允许客户点选择最近的配送中心

3. **改进路径合并策略**：
   - 当前实现采用贪心策略，可考虑添加局部搜索优化
   - 如2-opt算法交换路径中的边，进一步缩短总距离

4. **支持非对称距离**：
   - 修改`_calculate_distances`方法，允许输入非对称距离矩阵
   - 适用于有单向道路或交通拥堵的场景


#### 五、注意事项
1. 代码假设客户点坐标在二维平面上，使用欧几里得距离计算
2. 车辆容量约束严格执行，合并路径时会检查总需求
3. 可视化结果使用matplotlib，确保已安装相关库
4. 对于大规模问题（如客户数>100），建议使用更高效的算法或并行计算

通过这个框架，你可以轻松解决中小规模的车辆路径规划问题，并根据需要进行扩展和定制。